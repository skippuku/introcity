lib:
    interface for creating types/contexts
    intro_print circular detection
    accurate type display
    intro_print options
        whether to print unnamed members as if their members were within
        max depth
    sprint/mprint version of everything that uses stdout
    single header?
    the preprocessor and parser could be part of the lib?
    printf-like formatting print with insertions for types and values of types
    bitfield access

city:
    !! allocation options
    version for "release" without as much information where types are assumed to match
    attribute to specify allocation function
    type id's?
        could also check against type names or maybe name hashes

attribute:
    !! somehow handle data at an offset to a pointer ex. stb_ds
    allow attribute declarations with no namespace
    allow multiple aliases somehow
    more strict namespacing
        maybe use dot
    allow attributes in more places
        enum values
        functions
        function arguments
    impl: cache matching data
    @repress trait, disable propagation
    general 'terminated' attribute?
        could even be a value, then you could choose what counts as a terminator
    'from' attribute: allow conversion from a type, introlib will have builtin conversion functions for basic types
        some way to specify custom conversion functions
    attribute type: type
        as_enum for when you want an integer to be treated like an enum
            (or maybe just a general 'as')
    members of complex type can specify an attribute as a value: I(default default)
    parse c++ struct defaults as intro defaults?
    value(*@inherit): inherit base of type?

parse:
    !! GNU and MS alignment attributes
    !! GNU and MS pack attributes/pragma
    vector types (__m128, etc)
    Some way to get type location info
    ParseInfo: have everything, strip away unwated stuff at gen
    fix bitfield regression
    parse globals (for libraries that use extern)
    const flag?
    rudimentary C++ support
        function overloads
        namespaces
        member functions
        ignore templates
        operator overloads?

expr:
    support using const globals
    implement float math
    array subscript
    ability to return a value of any type
    compound literals
    handle character literals including L'x'
    handle strings next to each other

pre:
    FileInfo: add include location
    pragma that adds a file to make dependencies
    parse #line directives
    create #line directives?
    parse comments for documentation?
    fix -E spacing
    trim big newline gaps

gen:
    !! generate header and data seperately, linker will complain about multiple definitions when compiled in multiple objects
    c header: write protect?
    idea: use type infomation to generate the header
        some kind of create_c_constant function or something
    idea: stop using type information to generate anything because changing anything in intro.h can be a nightmare
    allow multiple outputs at once ex. header + city
    vector types (__m128, etc)
    option to create typedefs for structs and enums
    typeof with _Generic?

config:
    default program arguments
    allow config to be appended with another config?
    handle c type sizes
    static assert in .intro file if types don't match

test:
    add sanitized target
    test for errors that should be raised by the parser
    more rigorous tests

doc:

examples:
    !! more of these

misc:
    idea: some kind of plugin system
        for when you want to do metaprogramming, it seems more sensible to run your metaprogram along with intro \
          instead of compiling another program.
        these plugins could be inserted at different parts of the process, simplest case being, just run something with the type information before gen
        could be used to add checking to attributes, and maybe other kinds of enforcement
    idea: use parser to generate system headers with types only, no functions
        if we are to have our own system headers, we may as well also parse them into a binary format as well
    memory cleanup
    parse program options and pass only relevant ones to sub-processes
